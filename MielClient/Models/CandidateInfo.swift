//
// CandidateInfo.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct CandidateInfo: Codable, JSONEncodable, Hashable {

    public static let nameRule = StringRule(minLength: nil, maxLength: 16, pattern: nil)
    public static let surnameRule = StringRule(minLength: nil, maxLength: 64, pattern: nil)
    public static let patronymicRule = StringRule(minLength: nil, maxLength: 32, pattern: nil)
    public static let educationRule = StringRule(minLength: nil, maxLength: 128, pattern: nil)
    public static let countryRule = StringRule(minLength: nil, maxLength: 32, pattern: nil)
    public static let cityRule = StringRule(minLength: nil, maxLength: 32, pattern: nil)
    public static let resumeRule = StringRule(minLength: nil, maxLength: 128, pattern: nil)
    public static let achivmentObjectsRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 2147483647, exclusiveMaximum: false, multipleOf: nil)
    public static let achivmentClientsRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 2147483647, exclusiveMaximum: false, multipleOf: nil)
    public static let achivmentLeadsRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 2147483647, exclusiveMaximum: false, multipleOf: nil)
    public static let achivmentExclusivesRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 2147483647, exclusiveMaximum: false, multipleOf: nil)
    public static let achivmentDealsRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 2147483647, exclusiveMaximum: false, multipleOf: nil)
    public var id: Int
    public var name: String
    public var surname: String
    public var patronymic: String?
    public var birth: Date
    public var age: Int
    public var education: String?
    public var photo: String?
    public var country: String?
    public var city: String?
    public var resume: String?
    public var courses: [Course]
    public var updatedAt: Date
    public var isFavorite: Bool
    public var favoriteId: Int?
    public var isInvited: Bool
    public var achivmentObjects: Int?
    public var achivmentClients: Int?
    public var achivmentLeads: Int?
    public var achivmentExclusives: Int?
    public var achivmentDeals: Int?

    public init(id: Int, name: String, surname: String, patronymic: String? = nil, birth: Date, age: Int, education: String? = nil, photo: String? = nil, country: String? = nil, city: String? = nil, resume: String? = nil, courses: [Course], updatedAt: Date, isFavorite: Bool, favoriteId: Int? = nil, isInvited: Bool, achivmentObjects: Int? = nil, achivmentClients: Int? = nil, achivmentLeads: Int? = nil, achivmentExclusives: Int? = nil, achivmentDeals: Int? = nil) {
        self.id = id
        self.name = name
        self.surname = surname
        self.patronymic = patronymic
        self.birth = birth
        self.age = age
        self.education = education
        self.photo = photo
        self.country = country
        self.city = city
        self.resume = resume
        self.courses = courses
        self.updatedAt = updatedAt
        self.isFavorite = isFavorite
        self.favoriteId = favoriteId
        self.isInvited = isInvited
        self.achivmentObjects = achivmentObjects
        self.achivmentClients = achivmentClients
        self.achivmentLeads = achivmentLeads
        self.achivmentExclusives = achivmentExclusives
        self.achivmentDeals = achivmentDeals
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case name
        case surname
        case patronymic
        case birth
        case age
        case education
        case photo
        case country
        case city
        case resume
        case courses
        case updatedAt = "updated_at"
        case isFavorite = "is_favorite"
        case favoriteId = "favorite_id"
        case isInvited = "is_invited"
        case achivmentObjects = "achivment_objects"
        case achivmentClients = "achivment_clients"
        case achivmentLeads = "achivment_leads"
        case achivmentExclusives = "achivment_exclusives"
        case achivmentDeals = "achivment_deals"
    }
 
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            id = try container.decode(Int.self, forKey: .id)
            name = try container.decode(String.self, forKey: .name)
            surname = try container.decode(String.self, forKey: .surname)
            patronymic = try container.decodeIfPresent(String.self, forKey: .patronymic)
            
            let birthString = try container.decode(String.self, forKey: .birth)
            if let date = ISO8601DateFormatter().date(from: birthString) {
                birth = date
            } else if let date = DateFormatter.yyyyMMdd.date(from: birthString) {
                birth = date
            } else if let date = DateFormatter.ddMMyyyy.date(from: birthString) {
                birth = date
            } else {
                throw DecodingError.dataCorruptedError(forKey: .birth, in: container, debugDescription: "Invalid date format: \(birthString)")
            }
        


        age = try container.decode(Int.self, forKey: .age)
        education = try container.decodeIfPresent(String.self, forKey: .education)
        photo = try container.decodeIfPresent(String.self, forKey: .photo)
        country = try container.decodeIfPresent(String.self, forKey: .country)
        city = try container.decodeIfPresent(String.self, forKey: .city)
        resume = try container.decodeIfPresent(String.self, forKey: .resume)
        courses = try container.decode([Course].self, forKey: .courses)
            let updatedAtString = try container.decode(String.self, forKey: .updatedAt)
            if let date = ISO8601DateFormatter().date(from: updatedAtString) {
                updatedAt = date
            } else if let date = DateFormatter.yyyyMMdd.date(from: updatedAtString) {
                updatedAt = date
            } else if let date = DateFormatter.ddMMyyyy.date(from: updatedAtString) {
                updatedAt = date
            } else if let date = DateFormatter.yyyyMMddTHHmmssSSS.date(from: updatedAtString) {
                updatedAt = date
            } else {
                throw DecodingError.dataCorruptedError(forKey: .updatedAt, in: container, debugDescription: "Invalid date format: \(updatedAtString)")
            }

        isFavorite = try container.decode(Bool.self, forKey: .isFavorite)
        favoriteId = try container.decodeIfPresent(Int.self, forKey: .favoriteId)
        isInvited = try container.decode(Bool.self, forKey: .isInvited)
        achivmentObjects = try container.decodeIfPresent(Int.self, forKey: .achivmentObjects)
        achivmentClients = try container.decodeIfPresent(Int.self, forKey: .achivmentClients)
        achivmentLeads = try container.decodeIfPresent(Int.self, forKey: .achivmentLeads)
        achivmentExclusives = try container.decodeIfPresent(Int.self, forKey: .achivmentExclusives)
        achivmentDeals = try container.decodeIfPresent(Int.self, forKey: .achivmentDeals)
    }


    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(surname, forKey: .surname)
        try container.encodeIfPresent(patronymic, forKey: .patronymic)
        try container.encode(birth, forKey: .birth)
        try container.encode(age, forKey: .age)
        try container.encodeIfPresent(education, forKey: .education)
        try container.encodeIfPresent(photo, forKey: .photo)
        try container.encodeIfPresent(country, forKey: .country)
        try container.encodeIfPresent(city, forKey: .city)
        try container.encodeIfPresent(resume, forKey: .resume)
        try container.encode(courses, forKey: .courses)
        try container.encode(updatedAt, forKey: .updatedAt)
        try container.encode(isFavorite, forKey: .isFavorite)
        try container.encode(favoriteId, forKey: .favoriteId)
        try container.encode(isInvited, forKey: .isInvited)
        try container.encodeIfPresent(favoriteId, forKey: .favoriteId)
        try container.encodeIfPresent(achivmentObjects, forKey: .achivmentObjects)
        try container.encodeIfPresent(achivmentClients, forKey: .achivmentClients)
        try container.encodeIfPresent(achivmentLeads, forKey: .achivmentLeads)
        try container.encodeIfPresent(achivmentExclusives, forKey: .achivmentExclusives)
        try container.encodeIfPresent(achivmentDeals, forKey: .achivmentDeals)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension CandidateInfo: Identifiable {}
extension CandidateInfo {
    static var stub: CandidateInfo {
        CandidateInfo(
            id: Int.random(in: 1000...9999),
            name: ["Алексей", "Мария", "Ирина", "Павел", "Анна"].randomElement()!,
            surname: ["Иванов", "Смирнов", "Кузнецова", "Попова", "Сидоров"].randomElement()!,
            patronymic: ["Александрович", "Игоревна", "Владимирович", nil].randomElement() ?? "",
            birth: Calendar.current.date(byAdding: .year, value: -Int.random(in: 25...40), to: Date()) ?? Date(),
            age: Int.random(in: 25...40),
            education: ["Среднее", "Высшее", "Незаконченное высшее", nil].randomElement() ?? "",
            photo: nil,
            country: "Россия",
            city: ["Москва", "Санкт-Петербург", "Новосибирск", "Екатеринбург"].randomElement()!,
            resume: "Кандидат с опытом более \(Int.random(in: 3...10)) лет.",
            courses: [],
            updatedAt: Date(),
            isFavorite: Bool.random(),
            favoriteId: Int.random(in: 1...999),
            isInvited: Bool.random(),
            achivmentObjects: Int.random(in: 0...10),
            achivmentClients: Int.random(in: 0...20),
            achivmentLeads: Int.random(in: 0...15),
            achivmentExclusives: Int.random(in: 0...5),
            achivmentDeals: Int.random(in: 0...8)
        )
    }
}
private extension DateFormatter {
    static let yyyyMMdd: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        return formatter
    }()
    static let ddMMyyyy: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "dd.MM.yyyy"
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        return formatter
    }()
    static let yyyyMMddTHHmmssSSS: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSSSS"
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        return formatter
    }()
}
